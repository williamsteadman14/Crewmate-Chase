<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Mini Skeld â€” Full Game</title>
<style>
body { margin:0; overflow:hidden; background:black; touch-action:none; }
canvas { display:block; width:100vw; height:100vh; background:#1a1a2e; }
#joystick { position:absolute; bottom:40px; left:40px; width:100px; height:100px; background:rgba(255,255,255,0.1); border-radius:50%; touch-action:none; }
#stick { position:absolute; left:35px; top:35px; width:30px; height:30px; background:rgba(255,255,255,0.4); border-radius:50%; }
#killBtn { position:absolute; bottom:50px; right:40px; padding:15px 20px; font-size:16px; background:#222; color:white; border:none; border-radius:10px; overflow:hidden; }
#killText { position:relative; z-index:2; }
#killBar { position:absolute; bottom:0; left:0; height:5px; width:100%; background:red; transform:scaleX(0); transform-origin:left; }
#restartBtn { position:absolute; top:20px; left:50%; transform:translateX(-50%); padding:10px 20px; font-size:16px; border-radius:10px; }
#flash { position:absolute; top:0; left:0; width:100%; height:100%; background:red; opacity:0; transition:opacity 0.5s; pointer-events:none; }
#crewFlash { position:absolute; top:0; left:0; width:100%; height:100%; background:blue; opacity:0; transition:opacity 0.5s; pointer-events:none; }
#winMsg { position:absolute; top:50%; left:50%; transform:translate(-50%,-50%); font-family:Arial, sans-serif; font-size:40px; color:white; opacity:0; transition:opacity 0.5s; text-shadow:0 0 20px red; }
#crewMsg { position:absolute; top:50%; left:50%; transform:translate(-50%,-50%); font-family:Arial, sans-serif; font-size:40px; color:white; opacity:0; transition:opacity 0.5s; text-shadow:0 0 20px blue; }
</style>
</head>
<body>
<canvas id="game"></canvas>
<div id="joystick"><div id="stick"></div></div>
<button id="killBtn"><span id="killText">KILL</span><div id="killBar"></div></button>
<button id="restartBtn">RESTART</button>
<div id="flash"></div>
<div id="crewFlash"></div>
<div id="winMsg">IMPOSTER WINS!</div>
<div id="crewMsg">CREWMATES WIN!</div>

<script>
const canvas = document.getElementById("game");
const ctx = canvas.getContext("2d");
canvas.width = window.innerWidth;
canvas.height = window.innerHeight;

const tileSize = 40;

// Original working map
const originalMap = [
[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],
[1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
[1,0,1,1,1,0,1,1,1,0,1,1,1,0,1,1,1,0,0,1],
[1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,0,1],
[1,0,1,0,0,0,0,0,1,0,0,0,0,0,1,0,1,0,0,1],
[1,0,1,1,1,1,1,0,1,1,1,1,1,0,1,0,1,0,0,1],
[1,0,0,0,0,0,1,0,0,0,0,0,1,0,1,0,1,0,0,1],
[1,0,1,1,1,0,1,1,1,1,1,0,1,0,1,0,1,0,0,1],
[1,0,1,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,1],
[1,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,1],
[1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]
];

let map = [];
let deadTiles = [];
const aiPlayers = [];
const aiCount = 4;
const player = {x:tileSize*2, y:tileSize*2, color:"red", speed:2};
let killCooldown=false;

// Joystick
const joystick = document.getElementById("joystick");
const stick = document.getElementById("stick");
let joyX=0, joyY=0;
joystick.addEventListener("touchmove",(e)=>{
  const rect = joystick.getBoundingClientRect();
  const touch = e.touches[0];
  const dx = touch.clientX-(rect.left+rect.width/2);
  const dy = touch.clientY-(rect.top+rect.height/2);
  const dist = Math.min(Math.hypot(dx,dy),40);
  const angle = Math.atan2(dy,dx);
  joyX = Math.cos(angle)*(dist/40);
  joyY = Math.sin(angle)*(dist/40);
  stick.style.left = 35+Math.cos(angle)*dist+"px";
  stick.style.top = 35+Math.sin(angle)*dist+"px";
});
joystick.addEventListener("touchend",()=>{ joyX=0; joyY=0; stick.style.left="35px"; stick.style.top="35px"; });

// Kill button
const killBtn = document.getElementById("killBtn");
const killText = document.getElementById("killText");
const killBar = document.getElementById("killBar");

killBtn.addEventListener("click", ()=>{
  if(killCooldown) return;
  aiPlayers.forEach(ai=>{
    if(ai.alive && Math.hypot(ai.x-player.x, ai.y-player.y)<40){
      ai.alive=false;
      const tx = Math.floor(ai.x/tileSize);
      const ty = Math.floor(ai.y/tileSize);
      deadTiles.push({tx,ty});
    }
  });
  startCooldown();
  checkWin();
});

function startCooldown(){
  killCooldown=true;
  killText.textContent="";
  let progress=1;
  const duration=10000;
  const interval=50;
  const step=interval/duration;
  killBar.style.transform="scaleX(1)";
  const cd=setInterval(()=>{
    progress-=step;
    killBar.style.transform=`scaleX(${progress})`;
    if(progress<=0){
      clearInterval(cd);
      killCooldown=false;
      killText.textContent="KILL";
      killBar.style.transform="scaleX(0)";
    }
  }, interval);
}

// Collision
function isWall(x,y){
  const tx = Math.floor(x/tileSize);
  const ty = Math.floor(y/tileSize);
  return map[ty] && map[ty][tx] === 1;
}

// Random empty tile
function getEmptyTile(){
  let x,y;
  do{
    x=Math.floor(Math.random()*map[0].length);
    y=Math.floor(Math.random()*map.length);
  }while(map[y][x]===1);
  return {x:x*tileSize + tileSize/2, y:y*tileSize + tileSize/2};
}

// Connected random map generator
function generateConnectedMap(){
  const rows = originalMap.length;
  const cols = originalMap[0].length;
  const newMap = Array.from({length: rows}, () => Array(cols).fill(1));

  const startX = 2;
  const startY = 2;
  const stack = [{x:startX, y:startY}];
  newMap[startY][startX] = 0;

  const directions = [
    {dx:0, dy:-1}, {dx:0, dy:1},
    {dx:-1, dy:0}, {dx:1, dy:0}
  ];

  while(stack.length > 0){
    const current = stack[stack.length-1];
    const {x, y} = current;
    const shuffled = directions.sort(()=>Math.random()-0.5);
    let carved = false;

    for(const {dx, dy} of shuffled){
      const nx = x + dx*2;
      const ny = y + dy*2;
      if(ny>0 && ny<rows-1 && nx>0 && nx<cols-1 && newMap[ny][nx]===1){
        newMap[y+dy][x+dx] = 0;
        newMap[ny][nx] = 0;
        stack.push({x:nx, y:ny});
        carved = true;
        break;
      }
    }

    if(!carved) stack.pop();
  }

  // Add extra random paths
  for(let y=1; y<rows-1; y++){
    for(let x=1; x<cols-1; x++){
      if(newMap[y][x]===1 && Math.random()<0.1) newMap[y][x]=0;
    }
  }

  return newMap;
}

// Load map and AI
function loadMap(newMap){
  map.length=0;
  newMap.forEach(r=>map.push([...r]));
  player.x=tileSize*2; player.y=tileSize*2; player.speed=2;
  deadTiles.length=0;
  aiPlayers.length=0;
  for(let i=0;i<aiCount;i++){
    const pos=getEmptyTile();
    aiPlayers.push({x:pos.x, y:pos.y, color:"lime", alive:true, dirX:Math.random()*2-1, dirY:Math.random()*2-1, timer:Math.floor(Math.random()*80+20)});
  }
  killCooldown=false; killText.textContent="KILL"; killBar.style.transform="scaleX(0)";
  document.getElementById("winMsg").style.opacity=0;
  document.getElementById("crewMsg").style.opacity=0;
}

// Initial load
loadMap(originalMap);

// Restart button
document.getElementById("restartBtn").addEventListener("click", ()=>{ autoRestart(); });

// Auto restart after 3 seconds with connected map
function autoRestart(){
  const randomMap = generateConnectedMap();
  loadMap(randomMap);
}

// Update AI
function updateAI(ai){
  if(!ai.alive) return;
  ai.timer--;
  if(ai.timer<=0){ ai.dirX=Math.random()*2-1; ai.dirY=Math.random()*2-1; ai.timer=Math.floor(Math.random()*80+20); }
  const nx=ai.x+ai.dirX;
  const ny=ai.y+ai.dirY;
  if(!isWall(nx,ai.y)) ai.x=nx; else ai.dirX*=-1;
  if(!isWall(ai.x,ny)) ai.y=ny; else ai.dirY*=-1;
}

// Update player
function updatePlayer(){
  const nx=player.x+joyX*player.speed*1.6;
  const ny=player.y+joyY*player.speed*1.6;
  if(!isWall(nx,player.y)) player.x=nx;
  if(!isWall(player.x,ny)) player.y=ny;
}

// Check dead tile collision
function checkDeadTileCollision(){
  for(const ai of aiPlayers){
    if(!ai.alive) continue;
    const tx=Math.floor(ai.x/tileSize);
    const ty=Math.floor(ai.y/tileSize);
    for(const dead of deadTiles){
      if(dead.tx===tx && dead.ty===ty){
        document.getElementById("crewFlash").style.opacity=1;
        setTimeout(()=>{
          document.getElementById("crewFlash").style.opacity=0;
          document.getElementById("crewMsg").style.opacity=1;
          setTimeout(autoRestart,3000);
        },120);
        player.speed=0; aiPlayers.forEach(a=>a.speed=0);
        return;
      }
    }
  }
}

// Check win
function checkWin(){
  const aliveCrew = aiPlayers.filter(a=>a.alive).length;
  if(aliveCrew===0){
    document.getElementById("flash").style.opacity=1;
    setTimeout(()=>{
      document.getElementById("flash").style.opacity=0;
      document.getElementById("winMsg").style.opacity=1;
      setTimeout(autoRestart,3000);
    },120);
    player.speed=0; aiPlayers.forEach(a=>a.speed=0);
  }
}

// Draw
function draw(){
  ctx.clearRect(0,0,canvas.width,canvas.height);
  const camX=player.x-canvas.width/2;
  const camY=player.y-canvas.height/2;

  // Map
  for(let y=0;y<map.length;y++){
    for(let x=0;x<map[y].length;x++){
      ctx.fillStyle=map[y][x]?"#2c2c54":"#202040";
      ctx.fillRect(x*tileSize-camX, y*tileSize-camY, tileSize, tileSize);
    }
  }

  // Dead tiles
  deadTiles.forEach(d=>{
    ctx.fillStyle="rgba(0,0,255,0.3)";
    ctx.fillRect(d.tx*tileSize-camX, d.ty*tileSize-camY, tileSize, tileSize);
  });

  // AI
  aiPlayers.forEach(ai=>{
    ctx.fillStyle=ai.alive?ai.color:"gray";
    ctx.beginPath();
    ctx.arc(ai.x-camX, ai.y-camY,10,0,Math.PI*2);
    ctx.fill();
  });

  // Player
  ctx.fillStyle=player.color;
  ctx.beginPath();
  ctx.arc(player.x-camX, player.y-camY,12,0,Math.PI*2);
  ctx.fill();
}

// Main loop
function loop(){
  updatePlayer();
  aiPlayers.forEach(updateAI);
  checkDeadTileCollision();
  draw();
  requestAnimationFrame(loop);
}
loop();
</script>
</body>
</html>