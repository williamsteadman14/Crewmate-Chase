<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Mini Skeld â€” Full Game</title>
<style>
body { margin:0; overflow:hidden; background:black; touch-action:none; font-family:Arial, sans-serif;}
canvas { display:block; width:100vw; height:100vh; background:#1a1a2e; }
#joystick { position:absolute; bottom:40px; left:40px; width:100px; height:100px; background:rgba(255,255,255,0.1); border-radius:50%; touch-action:none; }
#stick { position:absolute; left:35px; top:35px; width:30px; height:30px; background:rgba(255,255,255,0.4); border-radius:50%; }
#killBtn { position:absolute; bottom:50px; right:40px; padding:15px 20px; font-size:16px; background:#222; color:white; border:none; border-radius:10px; overflow:hidden; }
#killText { position:relative; z-index:2; }
#killBar { position:absolute; bottom:0; left:0; height:5px; width:100%; background:red; transform:scaleX(0); transform-origin:left; }
#restartBtn { position:absolute; top:20px; left:50%; transform:translateX(-50%); padding:10px 20px; font-size:16px; border-radius:10px; }
#flash { position:absolute; top:0; left:0; width:100%; height:100%; background:red; opacity:0; transition:opacity 0.5s; pointer-events:none; }
#crewFlash { position:absolute; top:0; left:0; width:100%; height:100%; background:blue; opacity:0; transition:opacity 0.5s; pointer-events:none; }
#winMsg { position:absolute; top:50%; left:50%; transform:translate(-50%,-50%); font-family:Arial, sans-serif; font-size:40px; color:white; opacity:0; transition:opacity 0.5s; text-shadow:0 0 20px red;}
#crewMsg { position:absolute; top:50%; left:50%; transform:translate(-50%,-50%); font-family:Arial, sans-serif; font-size:40px; color:white; opacity:0; transition:opacity 0.5s; text-shadow:0 0 20px blue;}
#codePanel { position:absolute; top:10px; left:10px; padding:5px; border-radius:10px; background:rgba(255,255,255,0.1); display:flex; align-items:center; gap:5px; z-index:10; }
#codePanel input { padding:5px 8px; border-radius:5px; border:none; outline:none; font-size:14px; background:rgba(255,255,255,0.2); color:white; }
#codePanel button { padding:5px 10px; border-radius:5px; border:none; background:#222; color:white; cursor:pointer; font-size:14px; }
#codePanel button:hover { background:#444; }
#codeInstructions { 
  position:absolute; 
  top:55px; 
  left:10px; 
  color:white; 
  font-size:14px; 
  margin-top:8px; 
  background:rgba(0,0,0,0.5); 
  padding:8px 12px; 
  border-radius:8px; 
  z-index:10; 
  pointer-events:none;
}
</style>
</head>
<body>
<canvas id="game"></canvas>
<div id="joystick" style="display:none"><div id="stick"></div></div>
<button id="killBtn"><span id="killText">KILL</span><div id="killBar"></div></button>
<button id="restartBtn">RESTART</button>
<div id="flash"></div>
<div id="crewFlash"></div>
<div id="winMsg">IMPOSTER WINS!</div>
<div id="crewMsg">CREWMATES WIN!</div>

<!-- CODE PANEL (top left) -->
<div id="codePanel">
  <button id="codeToggle">CODE</button>
  <div id="codeContent" style="display:none; gap:5px; margin-left:5px; flex-direction:column;">
    <div style="display:flex; gap:5px;">
      <input id="codeInput" type="text" placeholder="Enter code">
      <button id="codeSubmit">Submit</button>
    </div>
  </div>
</div>

<!-- INSTRUCTIONS box, now OUTSIDE codePanel and always visible below it -->
<div id="codeInstructions">
  <b>Instructions:</b><br>
  WASD to move<br>
  K to kill<br>
  R to restart
</div>

<script>
// --- FORCE DESKTOP MODE (for debugging) ---
const computerControls = true; // Force desktop mode for now

const canvas = document.getElementById("game");
const ctx = canvas.getContext("2d");
canvas.width = window.innerWidth;
canvas.height = window.innerHeight;

const tileSize = 40;
const originalMap = [
[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],
[1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
[1,0,1,1,1,0,1,1,1,0,1,1,1,0,1,1,1,0,0,1],
[1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,0,1],
[1,0,1,0,0,0,0,0,1,0,0,0,0,0,1,0,1,0,0,1],
[1,0,1,1,1,1,1,0,1,1,1,1,1,0,1,0,1,0,0,1],
[1,0,0,0,0,0,1,0,0,0,0,0,1,0,1,0,1,0,0,1],
[1,0,1,1,1,0,1,1,1,1,1,0,1,0,1,0,1,0,0,1],
[1,0,1,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,1],
[1,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,1],
[1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]
];
let map = [], deadTiles = [], aiPlayers = [];
const aiCount = 4;
const player = {x:tileSize*2, y:tileSize*2, color:"red", speed:2};
let killCooldown=false;

// --- Desktop Controls ---
let keyX = 0, keyY = 0;
document.getElementById("joystick").style.display = "none"; // Hide joystick on desktop

window.addEventListener("keydown", e => {
  // Movement keys
  if (e.key === "ArrowUp" || e.key === "w") keyY = -1;
  if (e.key === "ArrowDown" || e.key === "s") keyY = 1;
  if (e.key === "ArrowLeft" || e.key === "a") keyX = -1;
  if (e.key === "ArrowRight" || e.key === "d") keyX = 1;

  // "k" for kill (only trigger on keydown, not repeat)
  if ((e.key === "k" || e.key === "K") && !killCooldown && !e.repeat) {
    let killed = false;
    aiPlayers.forEach(ai => {
      if (ai.alive && Math.hypot(ai.x - player.x, ai.y - player.y) < 40) {
        ai.alive = false;
        deadTiles.push({ tx: Math.floor(ai.x / tileSize), ty: Math.floor(ai.y / tileSize) });
        killed = true;
      }
    });
    if (killed) {
      startCooldown();
      checkWin();
    }
  }

  // "r" for restart (only trigger on keydown, not repeat)
  if ((e.key === "r" || e.key === "R") && !e.repeat) {
    autoRestart();
  }
});

window.addEventListener("keyup", e => {
  if (e.key === "ArrowUp" || e.key === "w") keyY = 0;
  if (e.key === "ArrowDown" || e.key === "s") keyY = 0;
  if (e.key === "ArrowLeft" || e.key === "a") keyX = 0;
  if (e.key === "ArrowRight" || e.key === "d") keyX = 0;
});

// --- Kill button ---
const killBtn = document.getElementById("killBtn");
const killText = document.getElementById("killText");
const killBar = document.getElementById("killBar");

killBtn.addEventListener("click", ()=>{
  if(killCooldown) return;
  let killed = false;
  aiPlayers.forEach(ai=>{
    if(ai.alive && Math.hypot(ai.x-player.x, ai.y-player.y)<40){
      ai.alive=false;
      deadTiles.push({tx:Math.floor(ai.x/tileSize),ty:Math.floor(ai.y/tileSize)});
      killed = true;
    }
  });
  if(killed) {
    startCooldown();
    checkWin();
  }
});

function startCooldown(){
  killCooldown=true;
  killText.textContent="";
  let progress=1;
  const duration=10000;
  const interval=50;
  const step=interval/duration;
  killBar.style.transform="scaleX(1)";
  const cd=setInterval(()=>{
    progress-=step;
    killBar.style.transform=`scaleX(${progress})`;
    if(progress<=0){
      clearInterval(cd);
      killCooldown=false;
      killText.textContent="KILL";
      killBar.style.transform="scaleX(0)";
    }
  }, interval);
}

// --- Map loading ---
function loadMap(newMap){
  map.length=0;
  newMap.forEach(r=>map.push([...r]));
  player.x=tileSize*2; player.y=tileSize*2; player.speed=2;
  deadTiles.length=0; aiPlayers.length=0;

  for(let i=0;i<aiCount;i++){
    const pos=getEmptyTile();
    aiPlayers.push({
      x:pos.x,
      y:pos.y,
      color:"lime",
      alive:true,
      dirX:Math.random()*2-1,
      dirY:Math.random()*2-1,
      timer:Math.floor(Math.random()*80+20),
      chaser: i===0
    });
  }
  killCooldown=false; killText.textContent="KILL"; killBar.style.transform="scaleX(0)";
  document.getElementById("winMsg").style.opacity=0;
  document.getElementById("crewMsg").style.opacity=0;
}
loadMap(originalMap);

// --- Restart ---
document.getElementById("restartBtn").addEventListener("click", ()=>{ autoRestart(); });
function autoRestart(){ loadMap(generateConnectedMap()); }

// --- Collision helpers ---
function isWall(x,y){ const tx=Math.floor(x/tileSize), ty=Math.floor(y/tileSize); return map[ty] && map[ty][tx]===1; }
function getEmptyTile(){ let x,y; do{x=Math.floor(Math.random()*map[0].length); y=Math.floor(Math.random()*map.length);}while(map[y][x]===1); return {x:x*tileSize+tileSize/2,y:y*tileSize+tileSize/2}; }
function generateConnectedMap(){
  const rows=originalMap.length, cols=originalMap[0].length;
  const newMap=Array.from({length:rows},()=>Array(cols).fill(1));
  const stack=[{x:2,y:2}]; newMap[2][2]=0;
  const dirs=[{dx:0,dy:-1},{dx:0,dy:1},{dx:-1,dy:0},{dx:1,dy:0}];
  while(stack.length>0){
    const current=stack[stack.length-1]; const {x,y}=current;
    const shuffled=dirs.sort(()=>Math.random()-0.5); let carved=false;
    for(const {dx,dy} of shuffled){
      const nx=x+dx*2, ny=y+dy*2;
      if(ny>0&&ny<rows-1&&nx>0&&nx<cols-1&&newMap[ny][nx]===1){
        newMap[y+dy][x+dx]=0; newMap[ny][nx]=0; stack.push({x:nx,y:ny}); carved=true; break;
      }
    }
    if(!carved) stack.pop();
  }
  for(let y=1;y<rows-1;y++) for(let x=1;x<cols-1;x++) if(newMap[y][x]===1 && Math.random()<0.1) newMap[y][x]=0;
  return newMap;
}

// --- Player movement ---
function updatePlayer(){
  // Use keyboard controls
  const nx = player.x + keyX * player.speed * 1.6;
  const ny = player.y + keyY * player.speed * 1.6;
  if(!isWall(nx,player.y)) player.x = nx;
  if(!isWall(player.x,ny)) player.y = ny;
}

// --- AI ---
function getNextStep(ai){
  const start = {x:Math.floor(ai.x/tileSize), y:Math.floor(ai.y/tileSize)};
  const goal = {x:Math.floor(player.x/tileSize), y:Math.floor(player.y/tileSize)};
  const queue = [start];
  const visited = Array.from({length:map.length},()=>Array(map[0].length).fill(false));
  const prev = Array.from({length:map.length},()=>Array(map[0].length).fill(null));
  visited[start.y][start.x]=true;
  while(queue.length>0){
    const current=queue.shift();
    if(current.x===goal.x && current.y===goal.y) break;
    const moves=[{dx:0,dy:-1},{dx:0,dy:1},{dx:-1,dy:0},{dx:1,dy:0}];
    for(const m of moves){
      const nx=current.x+m.dx, ny=current.y+m.dy;
      if(nx>=0&&ny>=0&&ny<map.length&&nx<map[0].length&&!visited[ny][nx]&&map[ny][nx]===0){
        visited[ny][nx]=true; prev[ny][nx]=current; queue.push({x:nx, y:ny});
      }
    }
  }
  let path=[], cur=goal;
  while(cur&&(cur.x!==start.x||cur.y!==start.y)){ path.push(cur); cur=prev[cur.y][cur.x]; }
  if(path.length>0) return path[path.length-1]; return start;
}

function updateAI(ai){
  if(!ai.alive) return;
  if(ai.chaser){
    const nextStep=getNextStep(ai);
    const nx = nextStep.x*tileSize + tileSize/2;
    const ny = nextStep.y*tileSize + tileSize/2;
    const speed = .75;
    const dx = nx - ai.x;
    const dy = ny - ai.y;
    const dist = Math.hypot(dx,dy);
    if(dist>0){ ai.x += dx/dist*speed; ai.y += dy/dist*speed; }
    if(Math.hypot(ai.x - player.x, ai.y - player.y)<tileSize/1.5){
      document.getElementById("crewFlash").style.opacity=1;
      setTimeout(()=>{ document.getElementById("crewFlash").style.opacity=0; document.getElementById("crewMsg").style.opacity=1; setTimeout(autoRestart,3000); },120);
      player.speed=0; aiPlayers.forEach(a=>a.speed=0);
    }
  } else {
    ai.timer--;
    if(ai.timer<=0){ ai.dirX=Math.random()*2-1; ai.dirY=Math.random()*2-1; ai.timer=Math.floor(Math.random()*80+20);}
    const nx=ai.x+ai.dirX, ny=ai.y+ai.dirY;
    if(!isWall(nx,ai.y)) ai.x=nx; else ai.dirX*=-1;
    if(!isWall(ai.x,ny)) ai.y=ny; else ai.dirY*=-1;
  }
}

// --- Dead tiles ---
function checkDeadTileCollision(){
  for(const ai of aiPlayers){ if(!ai.alive) continue;
    const tx=Math.floor(ai.x/tileSize), ty=Math.floor(ai.y/tileSize);
    for(const dead of deadTiles){ if(dead.tx===tx && dead.ty===ty){
      document.getElementById("crewFlash").style.opacity=1;
      setTimeout(() => {
        document.getElementById("crewMsg").style.opacity = 1;
        setTimeout(autoRestart, 3000);
      }, 120);
      player.speed = 0;
      aiPlayers.forEach(a => a.speed = 0);
      return;
    }}
  }
}

// --- Win check ---
function checkWin() {
  if (aiPlayers.filter(a => a.alive).length === 0) {
    document.getElementById("flash").style.opacity = 1;
    setTimeout(() => {
      document.getElementById("flash").style.opacity = 0;
      document.getElementById("winMsg").style.opacity = 1;
      setTimeout(autoRestart, 3000);
    }, 120);
    player.speed = 0;
    aiPlayers.forEach(a => a.speed = 0);
  }
}

// --- Draw everything ---
function draw() {
  ctx.clearRect(0, 0, canvas.width, canvas.height);
  const camX = player.x - canvas.width / 2;
  const camY = player.y - canvas.height / 2;

  // Draw map
  for (let y = 0; y < map.length; y++) {
    for (let x = 0; x < map[y].length; x++) {
      ctx.fillStyle = map[y][x] ? "#2c2c54" : "#202040";
      ctx.fillRect(x * tileSize - camX, y * tileSize - camY, tileSize, tileSize);
    }
  }

  // Draw dead tiles
  deadTiles.forEach(d => {
    ctx.fillStyle = "rgba(0,0,255,0.6)";
    ctx.fillRect(d.tx * tileSize - camX, d.ty * tileSize - camY, tileSize, tileSize);
  });

  // Draw AI
  aiPlayers.forEach(ai => {
    if (!ai.alive) return;
    ctx.fillStyle = ai.color;
    ctx.beginPath();
    ctx.arc(ai.x - camX, ai.y - camY, tileSize / 2.5, 0, Math.PI * 2);
    ctx.fill();
  });

  // Draw player
  ctx.fillStyle = player.color;
  ctx.beginPath();
  ctx.arc(player.x - camX, player.y - camY, tileSize / 2.5, 0, Math.PI * 2);
  ctx.fill();
}

// --- Game loop ---
function loop() {
  updatePlayer();
  aiPlayers.forEach(updateAI);
  checkDeadTileCollision();
  checkWin();
  draw();
  requestAnimationFrame(loop);
}
loop();

// --- Cheat codes ---
const codeInput = document.getElementById("codeInput");
const codeSubmit = document.getElementById("codeSubmit");
const codeToggle = document.getElementById("codeToggle");
const codeContent = document.getElementById("codeContent");

codeToggle.addEventListener("click", () => {
  codeContent.style.display = codeContent.style.display === "flex" ? "none" : "flex";
});

codeSubmit.addEventListener("click", () => {
  const code = codeInput.value.trim().toLowerCase();
  if (code === "killall") {
    aiPlayers.forEach(ai => ai.alive = false);
    checkWin();
  } else if (code === "speed") {
    player.speed = 5;
  } else if (code === "regen") {
    autoRestart();
  }
  codeInput.value = "";
});

// --- Canvas resize handler ---
window.addEventListener("resize", () => {
  canvas.width = window.innerWidth;
  canvas.height = window.innerHeight;
});
</script>
</body>
</html>
